// d.hatena.mac
$mn = "はてなダイアリー用マクロ - ";
// copyright (C) taketori <taketori at x10d.jp>
// ライセンスは、いわゆる「修正BSD」です。
// 動作環境は、秀丸(Ver.8.00以上)・COM・cmd.exe・同梱JScriptのインストール・読み出し・実行ができ、編集中ファイルの読み出し・実行、および保存先のフォルダにて読み出し・書き込みができる 環境。
// 設定によっては、本マクロと同じフォルダにて、ファイルを作成・書き込みできること。
// 以上の詳細は、配布ファイルに同梱の<README.txt>を参照。本マクロのマニュアルは<d.hatena.mac.txt>。

$id = "";

// 実行できない条件の時は、さっさと終了する。
if( version < 801 ){
	message "秀丸のバージョンが古いです。" + currentmacrobasename + "を終了します。";
	endmacro;
}

// 初期設定
	#_[0] = x;	#_[1] = y;
	$_[0] = searchbuffer;	#_[2] = searchoption;	$_[1] = getsearchhist(0);
	#_[3] = foundhilighting;	$_[2] = foundbuffer;	#_[4] = foundoption;
	#_[5] = overwrite;	#_[6] = browsemode;	#_[7] = readonly;	#_[8] = imestate;	#_[9] = freecursor;
	if( #_[5] )	overwriteswitch;
	if( #_[6] )	browsemodeswitch;
	if( #_[7] )	readonlyswitch;
	if( #_[8] )	imeswitch;
	if( #_[9] )	freecursorswitch;
setcompatiblemode 0x0002 | 0x0008 | 0x0200;		// 0x002=折りたたみを無視ししてなるべく維持, 0x0008=部分編集を無視してなるべく維持, 0x0200=検索での表示を「範囲選択」。

INIT:

	// 設定ファイル、X-WSSEヘッダ生成スクリプトの設置場所を取得する。
	$$ini = currentmacrofilename + ".ini";			// 設定ファイル
	$$wssegen = currentmacrofilename + ".js";		// X-WSSEヘッダ生成スクリプト
	if(existfile($$ini) == false || existfile($$wssegen) == false){
		call EXIT "以下のいずれかまたは両方のファイルがないので継続できません。\n\t" + $$ini + " (設定ファイル)\n\t" + $$wssegen + " (X-WSSEヘッダ生成スクリプト)\n配布ファイルに同梱の d.hatena.mac.ini.sample、d.hatena.mac.js.sample をコピー・改名してください";
	}
	call compile_js $$ini, $$wssegen;
	if($$return == "")	call EXIT $$wssegen + "から実行ファイルにコンパイルできませんでした。";
	$$wssegen = $$return;

MAIN:

	// X-WSSEデータを生成する。
	if($id == "")	$id = input($mn + "\nこのデータを、どのアカウントで投稿しますか。\nアカウント名を入力してください。");
	call runex_to $$wssegen +  " " + $id, 3, $$ini;
	if(##return)	call EXIT "X-WSSEの値を" + $$ini + "に追加する際に失敗しました。\nアカウント名か" + $$ini + "の書き込み権限・排他設定を疑ってください。";

	##char = inputchar($mn + "Press [P]ost, [G]et, [M]odify, [D]elete or [H]elp.");
	if     (##char == 'p')	call post $$ini;
	else if(##char == 'g')	call get_entry $$ini;
	else if(##char == 'm')	call mod_entry $$ini;
	else if(##char == 'd')	call del_entry $$ini;
	else if(##char == 'h')	call disp_help;

EXIT:

	if($$1 != "")	message $mn + "\n" + $$1;
	if($$2 != "")	$$ini = $$2;
	if($$ini != "")	writeinistr $$ini, currentmacrobasename, "x-wsse", 0;

	escape;
	moveto #_[0], #_[1];
	if( #_[5] )	overwriteswitch;
	if( #_[6] )	browsemodeswitch;
	if( #_[7] )	readonlyswitch;
	if( #_[8] )	imeswitch;
	if( #_[9] )	freecursorswitch;

endmacro;

disp_help:

	message $mn + "\n投稿:\t範囲選択をしておくと、その範囲の1行目をタイトルに、2行目以降を本文にします。\n\t範囲選択していない場合は、編集中の文章すべてを対象にします。\n修正:\t用いるデータは「投稿」と同様です。データは事前に「取得」しておくことをおすすめします。\n\t対象となる日記を選択するメニューを表示します。\n取得/削除:対象となる日記を選択するメニューを表示します。\n\n修正/削除の前には確認のダイアログを表示します。";

return;

post:
//arg: $1:iniファイル

	// 投稿する内容を生成する。
	call make_data;

	// はてなに接続して投稿する。
	call connect_hatena "POST", "http://d.hatena.ne.jp/" + $id + "/atom/blog",
		member(##return, "xml"), $$1;		//失敗の時はマクロ終了。
	/*NOTE: このマクロでは以下のような形式であることを前提に作っている。
	<link rel="edit" href="〜"/><link rel="alternate" 〜/>
	要するに、linkノードはrel=editを持つもの → rel=alternateを持つもの の順番である。*/
	title $mn + "投稿完了";
	##link = member(##return, "selectSingleNode", "//link");
	if(member(##link, "getAttribute", "rel") == "edit"){
		message $mn + "\n" + member(##link, "getAttribute", "href") + "\nに投稿しました。";
	}
	/*
	##attrs = member(member(##return, "selectSingleNode", "//link"), "attributes");
	##attr = getcollection(##attrs);
	if(member(##attr, "nodeName")  == "rel"
	&& member(##attr, "nodeValue") == "edit"){
		message $mn + "\n" + member(getcollection(##attrs), "nodeValue") + "\nに投稿しました。";
	}*/
	else{
		message $mn + "\n" + midstr(member(member(##return, "selectSingleNode", "//id"), "text"), strlen("tag:d.hatena.ne.jp,2008:"), ) + "\nに投稿しました。";
	}

return;

get_entry:
//arg: $1:iniファイル

	call get_list $$1, 1, "表示する";
	$$uri = $$return;
	call connect_hatena "GET", $$uri, "", $$1;		//失敗の時はマクロ終了。
	title $mn;
	question $mn + "\n以下のデータをカーソル部分に挿入します。\n[はい] = 挿入。[いいえ] = ダイアログで表示。\n\n" + $$uri;
	if(result)	insert $$uri + "\n" + member(member(##return, "selectSingleNode", "//title"), "text") + "\n" + member(member(##return, "selectSingleNode", "//hatena:syntax"), "text");
	else				message $$uri + "\n" + member(member(##return, "selectSingleNode", "//title"), "text") + "\n" + member(member(##return, "selectSingleNode", "//hatena:syntax"), "text");

return 0;

mod_entry:
//arg: $1:iniファイル
//TODO: 修正する日付を選択範囲から抽出する。

	call get_list $$1, 1, "修正する";
	$$uri = $$return;

	// 投稿する内容を生成する。
	call make_data;

	question $mn + "修正していいですか。";
	if(!result)	return;
	call connect_hatena "PUT", $$uri, member(##return, "xml"), $$1;		//失敗の時はマクロ終了。
	title $mn + "投稿完了";
	message $mn + "\n" + member(member(##return, "selectSingleNode", "//link"), "getAttribute", "href") + "\nを修正しました。";

return;

del_entry:
//arg: $1:iniファイル

	//TODO: 削除するものを、範囲選択、現在のカーソル行からも選べるようにする。
	call get_list $$1, 1, "削除する";
	title $mn;
	question $mn + "本当に削除しますか。\n" + $$return;
	if(!result)	return;
	call connect_hatena "DELETE", $$return, "", $$1;		//失敗の時はマクロ終了。
	message $mn + "\n削除しました。";

return 0;

get_list:
//arg: $1:iniファイル, #2:ページ数, $3:何の対象か

	// 2ページ以降の時は、前のページへの案内をつける。
	##i = 0;
	if(1 < ##2){
		$$menu[##i] = "&b <--- 前の20件 ---";
		##i = ##i + 1;
	}

	// 現在のページの20件を取得する。
	$$_ = "asdfghjklqwertyuiopvm";		// メニューの頭につけるあれ
	call connect_hatena "GET", "http://d.hatena.ne.jp/" + $id + "/atom/blog?page=" + str(##2),
	                    "", $$1;		//失敗の時はマクロ終了。
	##entrys = member(##return, "selectNodes", "//entry"); //NOTE: not ##entries
	##items = member(##entrys, "length");
	while(##i < ##items + (##2 != 1) ){
		##entry = getcollection(##entrys);
		$$menu[##i] = "&" + midstr($$_, ##i, 1) + " " + member(member(##entry, "selectSingleNode", "title"), "text");
		$$uri[##i] = member(member(##entry, "selectSingleNode", "link"), "getAttribute", "href");
		##i = ##i + 1;
	}

	// このページで20件あるときは次のページもあると見なして、次のページへの案内をつける。
	if(##i == 20 + (##2 != 1)){
		$$menu[##i] = "&n --- 次の20件 --->";
		##i = ##i + 1;
	}

	// メニューを表示する。
	title $mn + $$3 + "日記のタイトルをメニューの中から選択してください。";
	menuarray $$menu, ##i;
	if(result == 0)											call EXIT;
	if(result == 1 && ##2 != 1)		call get_list $$1, ##2 - 1;
	if(result == 21 + (##2 != 1))	call get_list $$1, ##2 + 1;
	else return $$uri[result - 1];

return $$return;

compile_js:
//arg: $1:設定ファイルのフルパス,  $2:X-WSSEヘッダ生成スクリプトのフルパス(存在確認済)
//ARG: $mn,  Registory
//ret: X-WSSEヘッダ生成実行ファイルのフルパス。(コンパイルに失敗したらマクロ終了)

	title $mn + $$2 + "を実行ファイルへコンパイルする準備をしています。";
	$$wssegen = leftstr($$2, strrstr($$2, ".js")) + ".exe";
	if(existfile($$wssegen))	call runex_to $$wssegen;		// 引数なしで起動したときはソースコードとの新旧比較。
	if(##return/*1=実行ファイルの方が新しい*/){
		title $mn + $$2 + "より実行ファイルの方が新しいので、コンパイルを中断しました。";
		return $$wssegen;
	}

	// コンパイルに利用するjsc.exeを指定する。
	$$jsc = getinistr($$1, currentmacrobasename, "jsc") + "\\jsc.exe";
	openreg "LOCALMACHINE", "SOFTWARE\\Microsoft\\.NETFramework";
	if(result){
		$$jsc = getregstr("InstallRoot") + $$jsc;
		closereg;
	}else{
		if(getinistr($$1, currentmacrobasename, "InstallRoot") == "")
			call runex_to "cmd.exe /C FOR /f \"skip=4 tokens=1,3\" %a IN ('reg.exe QUERY HKLM\\SOFTWARE\\Microsoft\\.NETFramework /v InstallRoot') DO @ECHO %a = %%b", 3, $$1;
		$$jsc = getinistr($$1, currentmacrobasename, "InstallRoot") + $$jsc;
	}
	if(!existfile($$jsc))	return;

	// コンパイルする。
	title $mn + "コンパイル中。少々お待ちを。:" +$$2 + " by " + $$jsc;
	call runex_to $$jsc + " /warnaserror+ /warn:0 /out:" + $$wssegen + " " + $$2;
	if(##return)	call EXIT $$jsc + " を起動して " + $$2 + " をコンパイルする際に失敗しました。";

return $$wssegen;

runex_to:
// 引数で指定されたプログラムをrunexを用いて実行し、アウトプット枠に出力する。
//arg: $1:実行するプログラムのフルパス, #2:出力する場所, $3:#2がファイルの時のファイル名
//ret: 0=正常に起動でき終了コード0だった。0以外=プログラムの起動に失敗か終了コードが0以外。

	runex $$1, 1/*sync:sync*/, 0, ""/*stdin:none*/, ##2, $$3/*stdout*/, 0, ""/*stderr:none*/, 1, ""/*folder:current*/, 2/*show:hide*/, 0/*nodraw:draw*/, 0/*code:ansi*/;

return (result == false) + getresultex(9);

make_data:
// 編集中の秀丸から必要なデータを抽出し、投稿用のデータにする。
// データの形式は1行目がタイトル、2行目以降が本文。タイトル行の前にヘッダ行があればそれを使う("^updated:\s*"があればその日付。"^subject:\s*"に該当するものがあればその行をタイトル行にしてそれ以外のを本文に)。
//arg:
//ret: #取得したDOMDocumentオブジェクトの番号

	$$template = currentmacrofilename + ".xml";
	call get_dom 0, $$template;		// 失敗したらマクロ終了なので##returnには必ず値が入る。
	##dom = ##return;

	if(selecting || rectselecting){
		escape;
		moveto2 seltopcolumn, seltoplineno;
		if(seltoplineno == selendlineno){
			setpropstr member(##dom, "selectSingleNode", "//title"), "text", gettext2(seltopcolumn, seltoplineno, selendcolumn, selendlineno);
		}else{
			setpropstr member(##dom, "selectSingleNode", "//title"), "text", gettext2(seltopcolumn, seltoplineno, linelen2, seltoplineno);
			setpropstr member(##dom, "selectSingleNode", "//content"), "text", gettext2(0, seltoplineno + 1, selendcolumn, selendlineno);
		}
	}else{
		gofiletop;
		setpropstr member(##dom, "selectSingleNode", "//title"), "text", gettext2(column, lineno, linelen2, lineno);
		gofileend;
		setpropstr member(##dom, "selectSingleNode", "//content"), "text", gettext2(0, 2, column, lineno);
	}

return ##return;

connect_hatena:
// XMLHTTPのopenメソッドを呼び出したのち、取得したXMLをDOMDocumentでパースする。
//arg: $1:接続方法(POST/GET等), $2:接続するURI, $3:sendの引数, $4:INIファイル名
//ret: get_dom(# "Msxml2.DOMDocument.3.0"オブジェクトの番号)。エラーの時はマクロ終了。

	// XMLを取得。
	title $mn + $$1 + "のために接続 " + $$2;
	##xmlhttp = createobject("Msxml2.XMLHTTP.3.0");
	if(!##xmlhttp)	##xmlhttp = createobject("Microsoft.XMLHTTP");
	if(!##xmlhttp)	call EXIT "XMLHTTPオブジェクトにアクセスできません。";

	callmethod ##xmlhttp, "Open", $$1, $$2, 0;
	callmethod ##xmlhttp, "setRequestHeader", "X-WSSE", getinistr($$4, currentmacrobasename, "x-wsse");
	callmethod ##xmlhttp, "setRequestHeader", "Content-Type", "text/xml";
	callmethod ##xmlhttp, "send", $$3;
	##status = getpropnum(##xmlhttp, "status");
	title $mn + "XMLHTTP result = " + str(##status) + ":" +  getpropstr(##xmlhttp, "statusText");

	if(300 <= ##status)	call EXIT $$1 + "できません。: " + $$2, $$4;
	if($$1 == "DELETE")	return ##status;
	call get_dom ##xmlhttp, $$2;

return ##return;

get_dom:
// DOMオブジェクトの確保。
//arg: #1:XMLHTTPオブジェクトの番号(0=$2をファイル名と見なしその内容を用いる), $2:接続ドメイン(#1=0以外) / 開くファイルのフルパス(#1=0)
//ARG: $mn
//ret: # "Msxml2.DOMDocument.3.0"オブジェクトの番号。エラーの時はマクロ終了。

	title $mn + "XMLを解析しています : " + $$2;
	##dom = createobject("Msxml2.DOMDocument.3.0");
	if(!##dom)	call EXIT "Msxml2.DOMDocument.3.0が使えない環境のため、続行できません。";
	setpropnum ##dom, "async", 0;

	// XML解析
	if(##1){
		//NOTE: 「member(member(##1,"responseXML"),"xml")」ではGET ID/atom/blogの時解析に失敗する。また「member(##1,"responseXML")」では##domに対してプロパティ・メソッドが発行できない。
		callmethod ##dom, "loadXML", getpropstr(##1, "responseText");
	}else{
		callmethod ##dom, "load", $$2;
	}
	if(member(member(##dom, "parseError"), "errorCode") != 0){
		call EXIT $$2 + " から取得したXMLファイルの解析に失敗しました:\n" + member(member(##dom, "parseError"), "reason");
	}
	title $mn + "XMLの解析を完了しました。: " + $$2;

return ##dom;

