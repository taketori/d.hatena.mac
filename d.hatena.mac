// d.hatena.mac
$mn = "はてなダイアリー用マクロ - ";
// copyright (C) taketori <taketori at x10d.jp>
// ライセンスは、いわゆる「修正BSD」です。
// 動作環境は、秀丸(Ver.8.00以上)・COM・cmd.exe・同梱JScriptのインストール・読み出し・実行ができ、編集中ファイルの読み出し・実行、および保存先のフォルダにて読み出し・書き込みができる 環境。
// 設定によっては、本マクロと同じフォルダにて、ファイルを作成・書き込みできること。
// 以上の詳細は、配布ファイルに同梱の<README.txt>を参照。本マクロのマニュアルは<d.hatena.mac.txt>。

$id = "";

// 実行できない条件の時は、さっさと終了する。
if( version < 801 ){
	message "秀丸のバージョンが古いです。" + currentmacrobasename + "を終了します。";
	endmacro;
}

// 初期設定
	#_[0] = x;	#_[1] = y;
	$_[0] = searchbuffer;	#_[2] = searchoption;	$_[1] = getsearchhist(0);
	#_[3] = foundhilighting;	$_[2] = foundbuffer;	#_[4] = foundoption;
	#_[5] = overwrite;	#_[6] = browsemode;	#_[7] = readonly;	#_[8] = imestate;	#_[9] = freecursor;
	if( #_[5] )	overwriteswitch;
	if( #_[6] )	browsemodeswitch;
	if( #_[7] )	readonlyswitch;
	if( #_[8] )	imeswitch;
	if( #_[9] )	freecursorswitch;
setcompatiblemode 0x0002 | 0x0008 | 0x0200;		// 0x002=折りたたみを無視ししてなるべく維持, 0x0008=部分編集を無視してなるべく維持, 0x0200=検索での表示を「範囲選択」。

INIT:

	// 設定ファイル、X-WSSEヘッダ生成スクリプトの設置場所を取得する。
	$$ini = currentmacrofilename + ".ini";			// 設定ファイル
	$$wssegen = currentmacrofilename + ".js";		// X-WSSEヘッダ生成スクリプト
	if(existfile($$ini) == false || existfile($$wssegen) == false){
		call EXIT "以下のいずれかまたは両方のファイルがないので継続できません。\n\t" + $$ini + " (設定ファイル)\n\t" + $$wssegen + " (X-WSSEヘッダ生成スクリプト)\n配布ファイルに同梱の d.hatena.mac.ini.sample、d.hatena.mac.js.sample をコピー・改名してください";
	}
	call compile_js $$ini, $$wssegen;
	if($$return == "")	call EXIT $$wssegen + "から実行ファイルにコンパイルできませんでした。";
	$$wssegen = $$return;

MAIN:

	// X-WSSEデータを生成する。
	if($id == "")	$id = input($mn + "\nこのデータを、どのアカウントで投稿しますか。\nアカウント名を入力してください。");
	call runex_to $$wssegen +  " " + $id, 3, $$ini;
	if(##return)	call EXIT "X-WSSEの値を" + $$ini + "に追加する際に失敗しました。\nアカウント名か" + $$ini + "の書き込み権限・排他設定を疑ってください。";

	##char = inputchar($mn + "Press [P]ost, [G]et, [M]odify, [D]elete or [H]elp.");
	if     (##char == 'p')	call post $$ini;
	else if(##char == 'g')	call get_entry $$ini;
	else if(##char == 'm')	call mod_entry $$ini;
	else if(##char == 'd')	call del_entry $$ini;
	else if(##char == 'h')	call disp_help;

EXIT:

	if($$1 != "")	message $mn + "\n" + $$1;
	if($$2 != "")	$$ini = $$2;
	if($$ini != "")	writeinistr $$ini, currentmacrobasename, "x-wsse", 0;

	escape;
	moveto #_[0], #_[1];
	if( #_[5] )	overwriteswitch;
	if( #_[6] )	browsemodeswitch;
	if( #_[7] )	readonlyswitch;
	if( #_[8] )	imeswitch;
	if( #_[9] )	freecursorswitch;

endmacro;

disp_help:

	message $mn + "\n投稿:\t範囲選択をしておくと、その範囲の1行目をタイトルに、2行目以降を本文にします。\n\t範囲選択していない場合は、編集中の文章すべてを対象にします。\n修正:\t用いるデータは「投稿」と同様です。データは事前に「取得」しておくことをおすすめします。\n\t対象となる日記を選択するメニューを表示します。\n取得/削除:対象となる日記を選択するメニューを表示します。\n\n修正/削除の前には確認のダイアログを表示します。";

return 0;

post:
//arg: $1:iniファイル

	// 投稿する内容を生成する。
	call make_data;
	##dom = ##return;

	// はてなに接続して投稿する。
	$$uri = getpropstr(member(##dom, "selectSingleNode", "//uri"), "text");
	call connect_hatena "POST", $$uri, ##dom, $$1;		//失敗の時はマクロ終了。
	##dom = ##return;
	/*NOTE: このマクロでは以下のような形式であることを前提に作っている。
	<link rel="edit" href="〜"/><link rel="alternate" 〜/>
	要するに、linkノードはrel=editを持つもの → rel=alternateを持つもの の順番である。*/
	title $mn + "投稿完了";
	##link = member(##dom, "selectSingleNode", "//link");
	if(member(##link, "getAttribute", "rel") == "edit"){
		message $mn + "\n" + member(##link, "getAttribute", "href") + "\nに投稿しました。";
	}else{
		message $mn + "\n" + midstr(member(member(##dom, "selectSingleNode", "//id"), "text"), strlen("tag:d.hatena.ne.jp,2008:"), ) + "\nに投稿しました。";
	}

return 0;

get_entry:
//arg: $1:iniファイル

	call get_list $$1, 1, "表示する";
	$$uri = $$return;
	call connect_hatena "GET", $$uri, 0, $$1;		//失敗の時はマクロ終了。
	##dom = ##return;
	title $mn;
	question $mn + "\n以下のデータをカーソル部分に挿入します。\n[はい] = 挿入。[いいえ] = ダイアログで表示。\n\n" + $$uri;
	//TODO: $$uriが/atom/blog/か/atom/draft/かによってヘッダタイトルを変更する。
	$$msg = "blog: " + $$uri + "\n"
	      + "updated: " + member(member(##dom, "selectSingleNode", "//updated"), "text") + "\n"
	      + member(member(##dom, "selectSingleNode", "//title"), "text") + "\n"
	      + member(member(##dom, "selectSingleNode", "//hatena:syntax"), "text");
	if(result)	insert $$msg;
	else				message $$msg;

return 0;

mod_entry:
//arg: $1:iniファイル

	// 投稿する内容を生成する。
	call make_data;
	##dom = ##return;
	$$uri = getpropstr(member(##dom, "selectSingleNode", "//uri"), "text");
	if($$uri == ""){
		call get_list $$1, 1, "修正する";
		$$uri = $$return;
	}

	question $mn + "修正していいですか。";
	if(!result)	return;
	call connect_hatena "PUT", $$uri, ##dom, $$1;		//失敗の時はマクロ終了。

	// 投稿に成功。
	title $mn + "投稿完了";
	message $mn + "\n" + member(member(##return, "selectSingleNode", "//link"), "getAttribute", "href") + "\nを修正しました。";

return 0;

del_entry:
//arg: $1:iniファイル

	call make_data;
	$$uri = getpropstr(member(##return, "selectSingleNode", "//uri"), "text");
	if($$uri == ""){
		call get_list $$1, 1, "削除する";
		$$uri = $$return;
	}
	title $mn;
	question $mn + "本当に削除しますか。\n" + $$uri;
	if(!result)	return;
	call connect_hatena "DELETE", $$uri, 0, $$1;		//失敗の時はマクロ終了。
	message $mn + "\n削除しました。";

return 0;

get_list:
//arg: $1:iniファイル, #2:ページ数, $3:何の対象か
//ret: $選択したエントリのURI

	// 2ページ以降の時は、前のページへの案内をつける。
	##i = 0;
	if(1 < ##2){
		$$menu[##i] = "&b <--- 前の20件 ---";
		##i = ##i + 1;
	}

	// 現在のページの20件を取得する。
	$$_ = "asdfghjklqwertyuiopvm";		// メニューの頭につけるあれ
	call connect_hatena "GET",
	                    "http://d.hatena.ne.jp/" + $id + "/atom/blog?page=" + str(##2),
	                    0, $$1;		//失敗の時はマクロ終了。
	##entrys = member(##return, "selectNodes", "//entry"); //NOTE: not ##entries
	##items = member(##entrys, "length");
	while(##i < ##items + (##2 != 1) ){
		##entry = getcollection(##entrys);
		$$menu[##i] = "&" + midstr($$_, ##i, 1) + " " + member(member(##entry, "selectSingleNode", "title"), "text");
		$$uri[##i] = member(member(##entry, "selectSingleNode", "link"), "getAttribute", "href");
		##i = ##i + 1;
	}

	// このページで20件あるときは次のページもあると見なして、次のページへの案内をつける。
	if(##items == 20){
		$$menu[##i] = "&n --- 次の20件 --->";
		##i = ##i + 1;
	}

	// メニューを表示する。
	title $mn + $$3 + "日記のタイトルをメニューの中から選択してください。";
	menuarray $$menu, ##i;
	if(result == 0)											call EXIT;
	if(result == 1 && ##2 != 1)		call get_list $$1, ##2 - 1;
	if(result == 21 + (##2 != 1))	call get_list $$1, ##2 + 1;
	else return $$uri[result - 1];

return $$return;

compile_js:
//arg: $1:設定ファイルのフルパス,  $2:X-WSSEヘッダ生成スクリプトのフルパス(存在確認済)
//ARG: $mn,  Registory
//ret: X-WSSEヘッダ生成実行ファイルのフルパス。(コンパイルに失敗したらマクロ終了)

	title $mn + $$2 + "を実行ファイルへコンパイルする準備をしています。";
	$$wssegen = leftstr($$2, strrstr($$2, ".js")) + ".exe";
	if(existfile($$wssegen))	call runex_to $$wssegen;		// 引数なしで起動したときはソースコードとの新旧比較。
	if(##return/*1=実行ファイルの方が新しい*/){
		title $mn + $$2 + "より実行ファイルの方が新しいので、コンパイルを中断しました。";
		return $$wssegen;
	}

	// コンパイルに利用するjsc.exeを指定する。
	$$jsc = getinistr($$1, currentmacrobasename, "jsc");
	// jsc.exeの場所を推定する。
	if($$jsc == "" || existfile($$jsc) == false){
		writeinistr $$1, currentmacrobasename, "jsc", 0;
		// .NET Frameworkのインストールディレクトリを推定する。
		//NOTE: 持ち出しキットを利用しているときは、秀丸のopenregの結果がfalseになるので使えない。またVer2以上の.NET Frameworkでないと面倒くさいことになるのでスクリプトでもできない。
		call runex_to "cmd.exe /C FOR /F \"skip=4 tokens=3\" %k IN ('reg.exe QUERY HKLM\\SOFTWARE\\Microsoft\\.NETFramework /v InstallRoot') DO @FOR /F \"delims= \" %a IN ('dir /O:-N /S /B %k\\jsc.exe') DO @ (echo jsc = \"%a\" && exit )", 3, $$1;
		$$jsc = getinistr($$1, currentmacrobasename, "jsc");
	}
	if(!existfile($$jsc))	return "";

	// コンパイルする。
	title $mn + "コンパイル中。少々お待ちを。:" +$$2 + " by " + $$jsc;
	call runex_to $$jsc + " /warnaserror+ /warn:0 /out:" + $$wssegen + " " + $$2;
	if(##return)	call EXIT $$jsc + " を起動して " + $$2 + " をコンパイルする際に失敗しました。";

return $$wssegen;

runex_to:
// 引数で指定されたプログラムをrunexを用いて実行し、アウトプット枠に出力する。
//arg: $1:実行するプログラムのフルパス, #2:出力する場所, $3:#2がファイルの時のファイル名
//ret: 0=正常に起動でき終了コード0だった。0以外=プログラムの起動に失敗か終了コードが0以外。

	runex $$1, 1/*sync:sync*/, 0, ""/*stdin:none*/, ##2, $$3/*stdout*/, 0, ""/*stderr:none*/, 1, ""/*folder:current*/, 2/*show:hide*/, 0/*nodraw:draw*/, 0/*code:ansi*/;

return (result == false) + getresultex(9);

make_data:
// 編集中の秀丸から必要なデータを抽出し、投稿用のデータにする。
//arg: --
//ret: #取得したDOMDocumentオブジェクトの番号

	$$make_data_mac = currentmacrofilename + ".makedata.mac";
	if(!existfile($$make_data_mac))	call EXIT $$make_data_mac + "がないので続行できません。";
	execmacro $$make_data_mac, $mn, currentmacrofilename;
	if(3 <= strlen(getresultex(-1)))	call EXIT getresultex(-1);		// 3文字以上ならたぶんエラーメッセージ。
	##ret = val(getresultex(-1));		// 3文字以下ならたぶん取得したDOMDocumentオブジェクトの番号。

return ##ret;

connect_hatena:
// XMLHTTPのopenメソッドを呼び出したのち、取得したXMLをDOMDocumentでパースする。
//arg: $1:接続方法(POST/GET等), $2:接続するURI, #3:XMLHTTPオブジェクトの番号(sendの引数), $4:INIファイル名
//ret: get_dom(# "Msxml2.DOMDocument.3.0"オブジェクトの番号)。エラーの時はマクロ終了。
//NOTE: 第3引数のオブジェクトは、この関数で破棄される。

	// XMLを取得。
	title $mn + $$1 + "のために接続 " + $$2;
	##xmlhttp = createobject("Msxml2.XMLHTTP.3.0");
	if(!##xmlhttp)	##xmlhttp = createobject("Microsoft.XMLHTTP");
	if(!##xmlhttp){
		call EXIT "XMLHTTPオブジェクトにアクセスできません。";
	}

	callmethod ##xmlhttp, "Open", $$1, $$2, 0;
	callmethod ##xmlhttp, "setRequestHeader", "X-WSSE", getinistr($$4, currentmacrobasename, "x-wsse");
	callmethod ##xmlhttp, "setRequestHeader", "Content-Type", "text/xml";
	// キャッシュ対策。
	callmethod ##xmlhttp, "setRequestHeader", "If-Modified-Since", "Thu, 01 Jun 1970 00:00:00 GMT";
	if(getinistr($$4, currentmacrobasename, "Cache-Control") != ""){
		callmethod ##xmlhttp, "setRequestHeader", "Cache-Control",
		           getinistr($$4, currentmacrobasename, "Cache-Control");
	}
	if(getininum($$4, currentmacrobasename, "Pragma")){
		callmethod ##xmlhttp, "setRequestHeader", "Pragma", "no-cache";
	}
	if(##3)	callmethod ##xmlhttp, "send", member(##3, "xml");
	else 		callmethod ##xmlhttp, "send", "";
	##status = getpropnum(##xmlhttp, "status");
	title $mn + "XMLHTTP result = " + str(##status) + ":" +  getpropstr(##xmlhttp, "statusText");

	if(300 <= ##status)	call EXIT $$1 + "できません。: " + $$2, $$4;
	if($$1 == "DELETE")	return ##status;
	call get_dom ##xmlhttp, $$2;

return ##return;

get_dom:
// DOMオブジェクトの確保。
//arg: #1:XMLHTTPオブジェクトの番号(0=$2をファイル名と見なしその内容を用いる), $2:接続ドメイン(#1=0以外) / 開くファイルのフルパス(#1=0)
//ARG: $mn
//ret: # "Msxml2.DOMDocument.3.0"オブジェクトの番号。エラーの時はマクロ終了。

	title $mn + "XMLを解析しています : " + $$2;
	##dom = createobject("Msxml2.DOMDocument.3.0");
	if(!result)	call EXIT "Msxml2.DOMDocument.3.0が使えない環境のため、続行できません。";
	setpropnum ##dom, "async", 0;

	// XML解析
	if(##1){
		//NOTE: 「member(member(##1,"responseXML"),"xml")」ではGET ID/atom/blogの時解析に失敗する。また「member(##1,"responseXML")」では##domに対してプロパティ・メソッドが発行できない。
		callmethod ##dom, "loadXML", getpropstr(##1, "responseText");
	}else{
		callmethod ##dom, "load", $$2;
	}
	if(member(member(##dom, "parseError"), "errorCode") != 0){
		call EXIT $$2 + " から取得したXMLファイルの解析に失敗しました:\n" + member(member(##dom, "parseError"), "reason");
	}
	title $mn + "XMLの解析を完了しました。: " + $$2;

return ##dom;

